{
  "name": "P5js typo",
  "tagline": "A repo to experiment with typography using p5*js and Rune.font",
  "body": "\r\n# p5js_typo\r\n\r\nA repo to experiment (have fun) with typography using p5*js and Rune.font\r\n\r\n\r\n## Interactive demos :\r\n\r\nlight rays : https://b2renger.github.io/p5js_typo/light_rays/index.html\r\n\r\n![light ray image](assets/Light_rays.png)\r\n\r\nspot lights : https://b2renger.github.io/p5js_typo/spot_lights/index.html\r\n\r\n![spot light image](assets/spot_lights.png)\r\n\r\n3d : https://b2renger.github.io/p5js_typo/3d/index.html\r\n\r\n![3d image](assets/3d.png)\r\n\r\nparticles lines : https://b2renger.github.io/p5js_typo/particles_lines/index.html\r\n\r\n![particle lines image](assets/particle_lines.png)\r\n\r\nparticles attract / repel : https://b2renger.github.io/p5js_typo/particles_attract_repel/index.html\r\n\r\n![particle image](assets/particles.png)\r\n\r\nscribble : https://b2renger.github.io/p5js_typo/scribble/index.html\r\n\r\n![scribble image](assets/scribble.png)\r\n\r\ntentacles : https://b2renger.github.io/p5js_typo/tentacles/index.html\r\n\r\n![tentacles image](assets/tentacles.png)\r\n\r\n\r\n## Tools\r\n\r\n### Drawing Framework\r\n\r\n**p5xjs** \r\n\r\nhttp://p5js.org/\r\n\r\nthis is our drawing library, it's used to setup the page, the canvas, programm the behaviors of animated objects etc. The website is full of ressources and tutorial to learn, you can also check Daniel Shiffman youtube channel.\r\n\r\n**scribble**\r\n\r\nhttps://github.com/generative-light/p5.scribble.js\r\n\r\nthis is a library for p5xjs and is only used in one experiment. It's made to make your lines and other shapes look as if the were drawn by hand.\r\n\r\n\r\n### Typographic library\r\n\r\n**Rune** \r\n\r\nhttps://github.com/runemadsen/rune.js \r\n\r\nRune is a full framework for graphic design. It is not limited to typography but we are using it mainly because of Rune.font addon and its support of paths.\r\n\r\n**Rune.font** \r\n\r\nhttps://github.com/runemadsen/rune.font.js\r\n\r\nRune.font is plugin for Rune, it allows us to load a font and convert its outline to Rune.path objects or a series of polygons that we will be able to use withing p5xjs.\r\n\r\n*Rune Madsen*, author of the Rune framework, has a great lecture about typography btw : http://printingcode.runemadsen.com/lecture-typography/\r\n\r\n\r\n### Gui library\r\n\r\n**dat.GUI** \r\n\r\nhttps://github.com/dataarts/dat.gui\r\n\r\ndat.GUI is lightweight user interface library for js. It provides a collapsing drawer in which you can place sliders, buttons etc.\r\n\r\n\r\n\r\n## Hands on tutorial\r\n\r\nI will not explain in details how p5xjs works, there is plenty of ressources on the web about that. Hrere I will try to explain how to interface all our tools together.\r\n\r\nFirst p5xjs uses two main functions\r\n\r\n```javascript\r\nfunction setup(){\r\n\r\n}\r\n``` \r\nand\r\n\r\n```javascript\r\nfunction draw(){\r\n\r\n}\r\n``` \r\n\r\nthe *setup* is used to initialize all our variables, create a canvas etc. it is called once : on the loading of our page.\r\nthe *draw* is an infinite loop that runs until the page is closed.\r\n\r\nA lot of the \"boilerplate\" code will happen in the former, whereas the actual drawing and interaction will happen in the later.\r\n\r\n### Boilerplate code\r\n\r\nthe base of code used in the examples is a bit complex, our goal is :\r\n\r\n1- to load a font, and analyse it using Rune.font to get a list of polygons we can use.\r\n\r\n2- setup some gui elements to change the font and few parameters aswell as a button to regenerate the path.\r\n\r\nHere is the code :\r\n\r\n```javascript\r\nvar f;\r\nvar path;\r\nvar polys;\r\nvar drawing = false;\r\nvar gui, params;\r\n\r\nfunction setup(){\r\n    createCanvas(windowWidth,windowHeight)  // create a full screen canvas\r\n    background(255)\r\n\r\n    // init all parameters\r\n    params = new Parameters();\r\n    // create dat.gui drawer\r\n    gui = new dat.GUI();\r\n    // gui setup\r\n    var f2 = gui.addFolder('configuration / path generation')\r\n   \r\n     // Configuration parameters\r\n    // font selector\r\n    f2.add(params, 'font', {Avenir : \"../fonts/AvenirNextLTW01-Medium.woff\", BlackOpsOne : \"../fonts/Black_Ops_One/BlackOpsOne-Regular.ttf\",\r\n                            Comfortaa : \"../fonts/Comfortaa/Comfortaa-Bold.ttf\",\r\n                            NovaMono : \"../fonts/Nova_Mono/NovaMono.ttf\", ShadowsIntoLight : \"../fonts/Shadows_Into_Light/ShadowsIntoLight.ttf\", \r\n                            Sniglet: \"../fonts/Sniglet/Sniglet-ExtraBold.ttf\",Tangerine : \"../fonts/Tangerine/Tangerine_Bold.ttf\",\r\n                            UnicaOne : \"../fonts/Unica_One/UnicaOne-Regular.ttf\"});  \r\n    f2.add(params, 'message');\r\n    f2.add(params, 'spacing', 1, 25).listen();\r\n    f2.add(params, 'size', 100, 1200).listen();\r\n    f2.add(params, 'regenerate');\r\n\r\n    // button\r\n    gui.add(params, 'save')\r\n\r\n    getPoints();\r\n}\r\n\r\n// this function loads a font, and create an array of polygons\r\n// a polygon being itself an array of vectors with x/y coordinates\r\nfunction getPoints(){\r\n    drawing = false;\r\n    // create new font : we use rune\r\n    console.log(params.font);\r\n    f = new Rune.Font(params.font) \r\n    // load the font\r\n    f.load(function(err){       \r\n        path = f.toPath(params.message, 0, 0, params.size)\r\n        polys = path.toPolygons({ spacing:params.spacing })\r\n        drawing = true;\r\n    });\r\n}\r\n\r\nvar Parameters = function(){\r\n\r\n    this.font = \"../fonts/AvenirNextLTW01-Medium.woff\"\r\n    this.message = 'p5*js';\r\n    this.spacing = 2;\r\n    this.size = 400;\r\n\r\n    this.regenerate = function(){\r\n        getPoints();\r\n    }\r\n\r\n    this.save = function(){\r\n        saveCanvas()\r\n    }\r\n\r\n}\r\n```\r\n\r\nQuite a few things happened here, so let's break it down.\r\n\r\n#### Loading a font and generating a path\r\n\r\nFirst we create a few variables that will be handy.\r\n\r\n```javascript\r\nvar f; // store the current font\r\nvar path; // store the path calculated from the current font\r\nvar polys; // store the array of polygons calculated from the current font\r\nvar drawing = false; // as loading is asynchron we need to keep track of its progression\r\nvar gui, params; // store gui related things.\r\n```\r\nThe boolean **drawing** is used to know when the loading of the font is finished : when the font is loaded we have a path varaible that is not null aswell as an array of polygons. This variable is used in the **getPoints()**, it is set to *false* at the beginning, and set to *true* when the font is finally loaded.\r\n\r\nSo let's now have a look at the **getPoints()** function\r\n\r\n```javascript\r\n// this function loads a font, and create an array of polygons\r\n// a polygon being itself an array of vectors with x/y coordinates\r\nfunction getPoints(){\r\n    drawing = false;\r\n    // create new font : we use rune\r\n    console.log(params.font);\r\n    f = new Rune.Font(params.font) \r\n    // load the font\r\n    f.load(function(err){       \r\n        path = f.toPath(params.message, 0, 0, params.size)\r\n        polys = path.toPolygons({ spacing:params.spacing })\r\n        drawing = true;\r\n    });\r\n}\r\n```\r\nit's pretty straight forward, and it runs with minimal changes from the Rune.font documentation example :\r\n\r\nhttp://printingcode.runemadsen.com/examples/typography/font/\r\n\r\nwe have a callback for when the loading is actually finished. When it's done we can actually draw. However you'll notice that I use things like *params.font*, *params.spacing* instead of the \"hardcoded values from the Rune documentation. This is because of the dat.GUI implementation for parameters. \r\n\r\n#### Gui creation\r\n\r\nThe main ressource to learn dat.GUI is located here for further references : http://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage\r\n\r\nOur boilerplate code involves being able to switch fonts, change the size of the message we want to display, and the spacing of points on the outline of the fonts. Those parameters can be changed via a gui, and once you are set you can click on *regenerate* to recalculate the **path** and the **polys** variable.\r\n\r\nTo do that dat.GUI is pretty easy. The variable named **gui** represents the things that will be displayed in the control drawer, whereas the variable named **params** is a javascript object that will simply hold our parameter values.\r\n\r\nFirst let's concentrate on params, on the setup we just have this line to initialize our object.\r\n\r\n``` javascript\r\n    // init all parameters\r\n    params = new Parameters();\r\n```\r\n\r\nand further on the code we have the actual object with its default parameters, which is just a data structure :\r\n\r\n```javascript\r\nvar Parameters = function(){\r\n\r\n    this.font = \"../fonts/AvenirNextLTW01-Medium.woff\"\r\n    this.message = 'p5*js';\r\n    this.spacing = 2;\r\n    this.size = 400;\r\n\r\n        this.regenerate = function(){\r\n        getPoints();\r\n    }\r\n\r\n    this.save = function(){\r\n        saveCanvas()\r\n    }\r\n\r\n}\r\n```\r\ndat.GUI will infer the kind of object it draws from the values of the varaibles. So the message by default is \"p5xjs\" but you can change it you will however need to click on the button *regenerate* to call the **getPoints()** function again to re-generate the path and our array of polygons. Since **this.regenerate** is a function it will be displayed as a button and once you click it you execute the code in-beetween the brackets.\r\n\r\nThe filling of our control drawer is done in the **setup()** function :\r\n\r\n``` javascript\r\n    // create dat.gui drawer\r\n    gui = new dat.GUI();\r\n    \r\n    // gui setup\r\n    var f2 = gui.addFolder('configuration / path generation')\r\n```\r\nwith the second line of code, we create a specific group of controls **f2** in our gui, which will be called 'configuration / path generation'. We will now add elements to this specific folder of controls.\r\n   \r\nFirst a font selection object :\r\n```javascript\r\n    f2.add(params, 'font', {Avenir : \"../fonts/AvenirNextLTW01-Medium.woff\", BlackOpsOne :     \"../fonts/Black_Ops_One/BlackOpsOne-Regular.ttf\", Comfortaa : \"../fonts/Comfortaa/Comfortaa-Bold.ttf\",\r\nNovaMono : \"../fonts/Nova_Mono/NovaMono.ttf\", ShadowsIntoLight : \"../fonts/Shadows_Into_Light/ShadowsIntoLight.ttf\", \r\nSniglet: \"../fonts/Sniglet/Sniglet-ExtraBold.ttf\",Tangerine : \"../fonts/Tangerine/Tangerine_Bold.ttf\", UnicaOne : \"../fonts/Unica_One/UnicaOne-Regular.ttf\"});  \r\n```\r\nwhen you pass a json-like object to the **.add()** function it will create a dropdown list with each *key* appearing as an element of the list.\r\n\r\nwe arleady mentionned *message* and *regenerate* entries, so we are left with the later two :\r\n```javascript\r\n    f2.add(params, 'spacing', 1, 25).listen();\r\n    f2.add(params, 'size', 100, 1200).listen();\r\n```\r\nthose will be sliders as **params.spacing** and **params.size** are numeric value, you can then pass the lower and higher bounds as arguments. \r\n\r\nYou can also notice the **.listen()** which will make the gui elements listen to the changes that would come from the programm. It can be usefull when creating presets - for instance in the \"tentacles\" example.\r\n\r\n\r\n### Drawing code\r\n\r\nWe now have the basics for our code base. All we have to do now is actually draw.\r\n\r\nIn most of the example, some \"drawing\" things are already happening in the **getPoints()** function because we want to create a collection of objects (in the sense of oop objects) that take the coordinates of each point of each polygon. In that case the drawing is merely about creating a **for** loop that runs through our collection and calls the appropriate behavior.\r\n\r\nBut we can also simply iterate through our array of polygons to draw a shape on each spot... something like :\r\n\r\n```javascript\r\nfor (var i=0; i < polys.length ; i++){\r\n           var poly = polys[i];\r\n           for(var j = 0; j < poly.state.vectors.length; j++) {\r\n                var vec1 = poly.state.vectors[j];\r\n          \r\n                noFill()\r\n                stroke(255);\r\n                strokeWeight(1);\r\n                scribble.scribbleEllipse(vec1.x, vec1.y,25,25);   \r\n           }\r\n}                \r\n```\r\n\r\n## Examples details \r\n\r\n### 3d\r\n\r\n### light rays\r\n\r\n### spot lights\r\n\r\n### particle lines\r\n\r\n### particles attract repel\r\n\r\n### scribble \r\n\r\n### tentacles\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}